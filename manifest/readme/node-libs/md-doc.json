{"name":"md-doc","summary":"<ul>\n<li>\n<p>该组件处理了数据请求的逻辑，在数据请求返回之前会渲染一个loading组件，在请求数据返回之后渲染业务组件</p>\n</li>\n<li>\n<p>在url，data，options其中之一发生改变的时候，组件会自动发出一个新的请求去请求数据</p>\n</li>\n<li>\n<p>可以传入多个请求，并发发送，在所有请求成功后渲染业务组件，当某一个请求的参数发生变化，单独发送这一个请求成功后渲染业务组件</p>\n</li>\n<li>\n<p>底层采用 <a href=\"https://github.com/axios/axios\">axios</a> 易于扩展</p>\n</li>\n<li>\n<p>用preset预制设置，全局生效，不用在每次调用都设置一些通用属性</p>\n</li>\n</ul>","api":"<h4>Fetch</h4>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n<th>类型</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>url</td>\n<td>需要请求接口的url</td>\n<td>string</td>\n<td>-</td>\n</tr>\n<tr>\n<td>data</td>\n<td>POST请求的data</td>\n<td>obj</td>\n<td>-</td>\n</tr>\n<tr>\n<td>options</td>\n<td>请求的其他参数，如method,headers等，详细请参考<a href=\"https://github.com/axios/axios\">axios</a></td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>loading</td>\n<td>在请求发出后没有返回结果时渲染的组件</td>\n<td>jsx</td>\n<td>null</td>\n</tr>\n<tr>\n<td>error</td>\n<td>请求返回后code不为200时渲染的组件，如果传入函数，参数中会接收到请求返回的错误msg</td>\n<td>jsx|func</td>\n<td>null</td>\n</tr>\n<tr>\n<td>empty</td>\n<td>请求未发出时渲染的组件</td>\n<td>jsx</td>\n<td>null</td>\n</tr>\n<tr>\n<td>auto</td>\n<td>是否自动发送请求，如果为false需要手动调用refresh方法才会发送请求，并且url,data,options发生变化后不会自动发送新的请求</td>\n<td>bool</td>\n<td>true</td>\n</tr>\n<tr>\n<td>component</td>\n<td>请求返回成功时需要渲染的组件</td>\n<td>React Component</td>\n<td>-</td>\n</tr>\n<tr>\n<td>render</td>\n<td>请求返回成功时执行的方法，改方法需要返回jsx，参数可以拿到{data,refresh,setData}，当存在component时改方法不会被执行</td>\n<td>func</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h4>FetchAll</h4>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n<th>类型</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fetchers</td>\n<td>需要请求的请求数组，数组中的每一项包含url,data,options,参考Fetch的url,data,options参数</td>\n<td>array</td>\n<td>-</td>\n</tr>\n<tr>\n<td>loading</td>\n<td>在请求发出后没有返回结果时渲染的组件</td>\n<td>jsx</td>\n<td>null</td>\n</tr>\n<tr>\n<td>error</td>\n<td>请求返回后code不为200时渲染的组件，如果传入函数，参数中会接收到请求返回的错误msg</td>\n<td>jsx|func</td>\n<td>null</td>\n</tr>\n<tr>\n<td>empty</td>\n<td>请求未发出时渲染的组件</td>\n<td>jsx</td>\n<td>null</td>\n</tr>\n<tr>\n<td>auto</td>\n<td>是否自动发送请求，如果为false需要手动调用refresh方法才会发送请求，并且url,data,options发生变化后不会自动发送新的请求</td>\n<td>bool</td>\n<td>true</td>\n</tr>\n<tr>\n<td>component</td>\n<td>请求返回成功时需要渲染的组件</td>\n<td>React Component</td>\n<td>-</td>\n</tr>\n<tr>\n<td>render</td>\n<td>请求返回成功时执行的方法，改方法需要返回jsx，参数可以拿到{data,refresh,setData}，当存在component时改方法不会被执行</td>\n<td>func</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h4>withFetch</h4>\n<p>高阶组件 Fetch组件的封装 withFetch(WrappedComponent) WrappedComponent为一个React Component,等价于给Fetch传入component参数</p>\n<h4>withFetchAll</h4>\n<p>高阶组件 FetchAll组件的封装 withFetchAll(WrappedComponent) WrappedComponent为一个React Component,等价于给FetchAll传入component参数</p>\n<h4>createWithFetch</h4>\n<p>withFetch的高阶函数，可以将部分参数提前传入，不必在调用withFetch(WrappedComponent) 时再传入参数</p>\n<h4>createWithFetchAll</h4>\n<p>withFetchAll的高阶函数，可以将部分参数提前传入，不必在调用withFetchAll(WrappedComponent) 时再传入参数</p>\n<h4>useFetch</h4>\n<p>React Hooks</p>\n<p>参数 useFetch(options)</p>\n<p>options:</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n<th>类型</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>url</td>\n<td>需要请求接口的url</td>\n<td>string</td>\n<td>-</td>\n</tr>\n<tr>\n<td>data</td>\n<td>POST请求的data</td>\n<td>obj</td>\n<td>-</td>\n</tr>\n<tr>\n<td>options</td>\n<td>请求的其他参数，如method,headers等，详细请参考<a href=\"https://github.com/axios/axios\">axios</a>｜obj</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>auto</td>\n<td>是否自动发送请求，如果为false需要手动调用refresh方法才会发送请求，并且url,data,options发生变化后不会自动发送新的请求</td>\n<td>bool</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<p>返回值 {isLoading, isComplete, errorMsg, results, refresh,setData}</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isLoading</td>\n<td>当前fetch组件是否正在加载</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>isComplete</td>\n<td>当前fetch组件是否已完成</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>errorMsg</td>\n<td>当前组件的请求错误信息</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>results</td>\n<td>当前组件的请求返回数据</td>\n<td>-</td>\n</tr>\n<tr>\n<td>refresh</td>\n<td>可以调用它手动重新发送请求的方法</td>\n<td>func</td>\n</tr>\n<tr>\n<td>setData</td>\n<td>可以调用它给fetch中保存值的state赋值</td>\n<td>func</td>\n</tr>\n</tbody>\n</table>\n<h4>useFetchAll</h4>\n<p>React Hooks</p>\n<p>参数 useFetchAll(options)</p>\n<p>options:</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n<th>类型</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fetchers</td>\n<td>需要请求的请求数组，数组中的每一项包含url,data,options,参考Fetch的url,data,options参数</td>\n<td>array</td>\n<td>-</td>\n</tr>\n<tr>\n<td>auto</td>\n<td>是否自动发送请求，如果为false需要手动调用refresh方法才会发送请求，并且url,data,options发生变化后不会自动发送新的请求</td>\n<td>bool</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<p>返回值 {isLoading, isComplete, errorMsg, results, refresh,setData}</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isLoading</td>\n<td>当前fetch组件是否正在加载</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>isComplete</td>\n<td>当前fetch组件是否已完成</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>errorMsg</td>\n<td>当前组件的请求错误信息</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>results</td>\n<td>当前组件的请求返回数据</td>\n<td>-</td>\n</tr>\n<tr>\n<td>refresh</td>\n<td>可以调用它手动重新发送请求的方法</td>\n<td>func</td>\n</tr>\n<tr>\n<td>setData</td>\n<td>可以调用它给fetch中保存值的state赋值</td>\n<td>func</td>\n</tr>\n</tbody>\n</table>\n<h4>preset 预制设置的方法 preset(options)</h4>\n<p>options</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n<th>类型</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ajax</td>\n<td>axios实例</td>\n<td>obj</td>\n<td>-</td>\n</tr>\n<tr>\n<td>loading</td>\n<td>在请求发出后没有返回结果时渲染的组件</td>\n<td>jsx</td>\n<td>null</td>\n</tr>\n<tr>\n<td>error</td>\n<td>请求返回后code不为200时渲染的组件，如果传入函数，参数中会接收到请求返回的错误msg</td>\n<td>jsx|func</td>\n<td>null</td>\n</tr>\n<tr>\n<td>empty</td>\n<td>请求未发出时渲染的组件</td>\n<td>jsx</td>\n<td>null</td>\n</tr>\n<tr>\n<td>transformResponse</td>\n<td>请求转换器，参数为response返回值为response需要在此方法将请求返回结果转换成规定的格式</td>\n<td>func</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h4>缓存接口的应用</h4>\n<p>Fetch options</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n<th>类型</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cache</td>\n<td>1、cache为bool类型，例如：&lt;br&gt;cache: true则启用内存内存缓存；&lt;br&gt;2、cache为对象类型，例如&lt;br&gt;cache:{&lt;br&gt;&nbsp;&nbsp;expire: 1000 * 60 * 5, // 过期时间  默认5分钟; 0:表示不过期 &lt;br&gt;&nbsp;&nbsp;storage: false, // 是否开启本地缓存&lt;br&gt;&nbsp;&nbsp;storage_expire: 1000 * 60 * 5, // 本地缓存过期时间  默认5分钟; 0:表示不过期&lt;br&gt;&nbsp;&nbsp; max_cache_size: 15&lt;br&gt;}</td>\n<td>bool,object</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>","example":{"isFull":false,"className":"md_doc_af3fc","style":"","list":[{"title":"一个例子","description":"这是一个示例，这是一个示例","scope":[],"code":"const BasicExample = () => {\n\n    const text = `\n    内容描述文字，通常是一个段落，会出现折行。内容描述文字，通常是一个段落，会出现折行。内容描述文字，通常是一个段落，会出现折行。\n  `;\n\n    return (\n        <Collapse defaultActiveKey={['1']} accordion>\n            <Collapse.Panel header=\"标题文字 1\" key=\"1\">\n                {text}\n            </Collapse.Panel>\n            <Collapse.Panel header=\"标题文字 2\" key=\"2\">\n                {text}\n            </Collapse.Panel>\n            <Collapse.Panel header=\"标题文字 3\" key=\"3\">\n                {text}\n            </Collapse.Panel>\n        </Collapse>\n    );\n};\n\nReactDOM.render(<BasicExample />,document.getElementById('eui-example-runner'));\n\n"},{"title":"一个例子2","description":"这是一个示例，这是一个示例2","scope":[],"code":"const BasicExample = () => {\n\n    const text = `\n    内容描述文字，通常是一个段落，会出现折行。内容描述文字，通常是一个段落，会出现折行。内容描述文字，通常是一个段落，会出现折行。\n  `;\n\n    return (\n        <Collapse defaultActiveKey={['1']} accordion>\n            <Collapse.Panel header=\"标题文字 1\" key=\"1\">\n                {text}\n            </Collapse.Panel>\n            <Collapse.Panel header=\"标题文字 2\" key=\"2\">\n                {text}\n            </Collapse.Panel>\n            <Collapse.Panel header=\"标题文字 3\" key=\"3\">\n                {text}\n            </Collapse.Panel>\n        </Collapse>\n    );\n};\n\nReactDOM.render(<BasicExample />,document.getElementById('eui-example-runner'));\n\n"}]}}
